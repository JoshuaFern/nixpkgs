From 49f164b061d861386e59fccbbdbbec88cff11be9 Mon Sep 17 00:00:00 2001
From: Martin Peres <martin.peres@linux.intel.com>
Date: Wed, 6 Jun 2018 17:26:34 +0300
Subject: [PATCH 01/11] modesetting: make drmmode_shadow_allocate more generic

To do so, introduce a drmmode_scanout_rec structure that contains:
 - the DRM BO
 - the DRM FB id

We then take the generic part of drmmode_shadow_allocate that creates a
scanable buffer and move it to drmmode_scanout_allocate().

Signed-off-by: Martin Peres <martin.peres@linux.intel.com>
---
 hw/xfree86/drivers/modesetting/dri2.c         |  2 +-
 .../drivers/modesetting/drmmode_display.c     | 60 ++++++++++++-------
 .../drivers/modesetting/drmmode_display.h     |  8 ++-
 hw/xfree86/drivers/modesetting/present.c      |  2 +-
 4 files changed, 46 insertions(+), 26 deletions(-)

diff --git a/hw/xfree86/drivers/modesetting/dri2.c b/hw/xfree86/drivers/modesetting/dri2.c
index 96eaaaaf7..e0f4d80c9 100644
--- a/hw/xfree86/drivers/modesetting/dri2.c
+++ b/hw/xfree86/drivers/modesetting/dri2.c
@@ -545,7 +545,7 @@ can_exchange(ScrnInfoPtr scrn, DrawablePtr draw,
 
         /* Don't do pageflipping if CRTCs are rotated. */
 #ifdef GLAMOR_HAS_GBM
-        if (drmmode_crtc->rotate_bo.gbm)
+        if (drmmode_crtc->shadow_rotated.bo.gbm)
             return FALSE;
 #endif
 
diff --git a/hw/xfree86/drivers/modesetting/drmmode_display.c b/hw/xfree86/drivers/modesetting/drmmode_display.c
index f6f2e9fd1..b6aa8c8d7 100644
--- a/hw/xfree86/drivers/modesetting/drmmode_display.c
+++ b/hw/xfree86/drivers/modesetting/drmmode_display.c
@@ -616,8 +616,8 @@ drmmode_crtc_get_fb_id(xf86CrtcPtr crtc, uint32_t *fb_id, int *x, int *y)
             *x = drmmode_crtc->prime_pixmap_x;
         *y = 0;
     }
-    else if (drmmode_crtc->rotate_fb_id) {
-        *fb_id = drmmode_crtc->rotate_fb_id;
+    else if (drmmode_crtc->shadow_rotated.fb_id) {
+        *fb_id = drmmode_crtc->shadow_rotated.fb_id;
         *x = *y = 0;
     }
     else {
@@ -1785,34 +1785,50 @@ drmmode_set_scanout_pixmap(xf86CrtcPtr crtc, PixmapPtr ppix)
                                              &drmmode_crtc->prime_pixmap);
 }
 
-static void *
-drmmode_shadow_allocate(xf86CrtcPtr crtc, int width, int height)
+static Bool
+drmmode_scanout_allocate(xf86CrtcPtr crtc, int width, int height,
+                         drmmode_shadow_scanout_ptr scanout)
 {
     drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
     drmmode_ptr drmmode = drmmode_crtc->drmmode;
     int ret;
 
-    if (!drmmode_create_bo(drmmode, &drmmode_crtc->rotate_bo,
+    if (!drmmode_create_bo(drmmode, &scanout->bo,
                            width, height, drmmode->kbpp)) {
         xf86DrvMsg(crtc->scrn->scrnIndex, X_ERROR,
-               "Couldn't allocate shadow memory for rotated CRTC\n");
-        return NULL;
+                   "Couldn't allocate scanout memory\n");
+        return FALSE;
     }
 
-    ret = drmmode_bo_import(drmmode, &drmmode_crtc->rotate_bo,
-                            &drmmode_crtc->rotate_fb_id);
+    ret = drmmode_bo_import(drmmode, &scanout->bo,
+                            &scanout->fb_id);
 
     if (ret) {
-        ErrorF("failed to add rotate fb\n");
-        drmmode_bo_destroy(drmmode, &drmmode_crtc->rotate_bo);
-        return NULL;
+        ErrorF("failed to add scanout fb\n");
+        drmmode_bo_destroy(drmmode, &scanout->bo);
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+static void *
+drmmode_shadow_allocate(xf86CrtcPtr crtc, int width, int height)
+{
+    drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
+    drmmode_ptr drmmode = drmmode_crtc->drmmode;
+
+    if (!drmmode_scanout_allocate(crtc, width, height,
+                                  &drmmode_crtc->shadow_rotated)) {
+        xf86DrvMsg(crtc->scrn->scrnIndex, X_ERROR,
+                   "Couldn't allocate shadow memory for rotated CRTC\n");
     }
 
 #ifdef GLAMOR_HAS_GBM
     if (drmmode->gbm)
-        return drmmode_crtc->rotate_bo.gbm;
+        return drmmode_crtc->shadow_rotated.bo.gbm;
 #endif
-    return drmmode_crtc->rotate_bo.dumb;
+    return drmmode_crtc->shadow_rotated.bo.dumb;
 }
 
 static PixmapPtr
@@ -1856,14 +1872,14 @@ drmmode_shadow_create(xf86CrtcPtr crtc, void *data, int width, int height)
         }
     }
 
-    if (!drmmode_bo_has_bo(&drmmode_crtc->rotate_bo)) {
+    if (!drmmode_bo_has_bo(&drmmode_crtc->shadow_rotated.bo)) {
         xf86DrvMsg(scrn->scrnIndex, X_ERROR,
                    "Couldn't allocate shadow pixmap for rotated CRTC\n");
         return NULL;
     }
 
-    pPixData = drmmode_bo_map(drmmode, &drmmode_crtc->rotate_bo);
-    rotate_pitch = drmmode_bo_get_pitch(&drmmode_crtc->rotate_bo),
+    pPixData = drmmode_bo_map(drmmode, &drmmode_crtc->shadow_rotated.bo);
+    rotate_pitch = drmmode_bo_get_pitch(&drmmode_crtc->shadow_rotated.bo),
 
     rotate_pixmap = drmmode_create_pixmap_header(scrn->pScreen,
                                                  width, height,
@@ -1878,7 +1894,7 @@ drmmode_shadow_create(xf86CrtcPtr crtc, void *data, int width, int height)
         return NULL;
     }
 
-    drmmode_set_pixmap_bo(drmmode, rotate_pixmap, &drmmode_crtc->rotate_bo);
+    drmmode_set_pixmap_bo(drmmode, rotate_pixmap, &drmmode_crtc->shadow_rotated.bo);
 
     return rotate_pixmap;
 }
@@ -1894,11 +1910,11 @@ drmmode_shadow_destroy(xf86CrtcPtr crtc, PixmapPtr rotate_pixmap, void *data)
     }
 
     if (data) {
-        drmModeRmFB(drmmode->fd, drmmode_crtc->rotate_fb_id);
-        drmmode_crtc->rotate_fb_id = 0;
+        drmModeRmFB(drmmode->fd, drmmode_crtc->shadow_rotated.fb_id);
+        drmmode_crtc->shadow_rotated.fb_id = 0;
 
-        drmmode_bo_destroy(drmmode, &drmmode_crtc->rotate_bo);
-        memset(&drmmode_crtc->rotate_bo, 0, sizeof drmmode_crtc->rotate_bo);
+        drmmode_bo_destroy(drmmode, &drmmode_crtc->shadow_rotated.bo);
+        memset(&drmmode_crtc->shadow_rotated.bo, 0, sizeof drmmode_crtc->shadow_rotated.bo);
     }
 }
 
diff --git a/hw/xfree86/drivers/modesetting/drmmode_display.h b/hw/xfree86/drivers/modesetting/drmmode_display.h
index cde661450..499a95c39 100644
--- a/hw/xfree86/drivers/modesetting/drmmode_display.h
+++ b/hw/xfree86/drivers/modesetting/drmmode_display.h
@@ -150,6 +150,11 @@ typedef struct {
     uint64_t *modifiers;
 } drmmode_format_rec, *drmmode_format_ptr;
 
+typedef struct {
+    drmmode_bo bo;
+    unsigned fb_id;
+} drmmode_shadow_scanout_rec, *drmmode_shadow_scanout_ptr;
+
 typedef struct {
     drmmode_ptr drmmode;
     drmModeCrtcPtr mode_crtc;
@@ -166,8 +171,7 @@ typedef struct {
     uint32_t num_formats;
     drmmode_format_rec *formats;
 
-    drmmode_bo rotate_bo;
-    unsigned rotate_fb_id;
+    drmmode_shadow_scanout_rec shadow_rotated;
 
     PixmapPtr prime_pixmap;
     PixmapPtr prime_pixmap_back;
diff --git a/hw/xfree86/drivers/modesetting/present.c b/hw/xfree86/drivers/modesetting/present.c
index dda7cc064..a3f4e6aca 100644
--- a/hw/xfree86/drivers/modesetting/present.c
+++ b/hw/xfree86/drivers/modesetting/present.c
@@ -238,7 +238,7 @@ ms_present_check_flip(RRCrtcPtr crtc,
         drmmode_crtc_private_ptr drmmode_crtc = config->crtc[i]->driver_private;
 
         /* Don't do pageflipping if CRTCs are rotated. */
-        if (drmmode_crtc->rotate_bo.gbm)
+        if (drmmode_crtc->shadow_rotated.bo.gbm)
             return FALSE;
 
         if (ms_crtc_on(config->crtc[i]))
-- 
2.18.1


From 4de78ece2d6152551dda5043924224f48f60d3e3 Mon Sep 17 00:00:00 2001
From: Martin Peres <martin.peres@linux.intel.com>
Date: Wed, 6 Jun 2018 17:59:02 +0300
Subject: [PATCH 02/11] modesetting: make drmmode_shadow_create more generic

To do so:
 - add a pixmap field to the drmmode_scanout_rec structure
 - split out the pixmap-creation out of drmmode_shadow_create
   into drmmode_scanout_pixmap_create()

Signed-off-by: Martin Peres <martin.peres@linux.intel.com>
---
 .../drivers/modesetting/drmmode_display.c     | 71 +++++++++++--------
 .../drivers/modesetting/drmmode_display.h     |  1 +
 2 files changed, 44 insertions(+), 28 deletions(-)

diff --git a/hw/xfree86/drivers/modesetting/drmmode_display.c b/hw/xfree86/drivers/modesetting/drmmode_display.c
index b6aa8c8d7..b1d2cbffa 100644
--- a/hw/xfree86/drivers/modesetting/drmmode_display.c
+++ b/hw/xfree86/drivers/modesetting/drmmode_display.c
@@ -1853,50 +1853,65 @@ drmmode_create_pixmap_header(ScreenPtr pScreen, int width, int height,
 static Bool
 drmmode_set_pixmap_bo(drmmode_ptr drmmode, PixmapPtr pixmap, drmmode_bo *bo);
 
-static PixmapPtr
-drmmode_shadow_create(xf86CrtcPtr crtc, void *data, int width, int height)
+static Bool
+drmmode_scanout_pixmap_create(xf86CrtcPtr crtc, drmmode_shadow_scanout_ptr scanout)
 {
     ScrnInfoPtr scrn = crtc->scrn;
     drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
     drmmode_ptr drmmode = drmmode_crtc->drmmode;
-    uint32_t rotate_pitch;
-    PixmapPtr rotate_pixmap;
+    uint32_t pitch;
+    PixmapPtr pixmap;
     void *pPixData = NULL;
 
-    if (!data) {
-        data = drmmode_shadow_allocate(crtc, width, height);
-        if (!data) {
-            xf86DrvMsg(scrn->scrnIndex, X_ERROR,
-                       "Couldn't allocate shadow pixmap for rotated CRTC\n");
-            return NULL;
-        }
-    }
-
-    if (!drmmode_bo_has_bo(&drmmode_crtc->shadow_rotated.bo)) {
+    if (!drmmode_bo_has_bo(&scanout->bo)) {
         xf86DrvMsg(scrn->scrnIndex, X_ERROR,
-                   "Couldn't allocate shadow pixmap for rotated CRTC\n");
-        return NULL;
+                   "Couldn't allocate scanout pixmap because no scanout BO is present\n");
+        return FALSE;
     }
 
-    pPixData = drmmode_bo_map(drmmode, &drmmode_crtc->shadow_rotated.bo);
-    rotate_pitch = drmmode_bo_get_pitch(&drmmode_crtc->shadow_rotated.bo),
+    pPixData = drmmode_bo_map(drmmode, &scanout->bo);
+    pitch = drmmode_bo_get_pitch(&scanout->bo),
 
-    rotate_pixmap = drmmode_create_pixmap_header(scrn->pScreen,
-                                                 width, height,
-                                                 scrn->depth,
-                                                 drmmode->kbpp,
-                                                 rotate_pitch,
-                                                 pPixData);
+    pixmap = drmmode_create_pixmap_header(scrn->pScreen,
+                                          scanout->bo.width,
+                                          scanout->bo.height,
+                                          scrn->depth,
+                                          drmmode->kbpp,
+                                          pitch,
+                                          pPixData);
 
-    if (rotate_pixmap == NULL) {
+    if (pixmap == NULL) {
         xf86DrvMsg(scrn->scrnIndex, X_ERROR,
                    "Couldn't allocate shadow pixmap for rotated CRTC\n");
-        return NULL;
+        return FALSE;
     }
 
-    drmmode_set_pixmap_bo(drmmode, rotate_pixmap, &drmmode_crtc->shadow_rotated.bo);
+    if (!drmmode_set_pixmap_bo(drmmode, pixmap, &scanout->bo))
+        return FALSE;
 
-    return rotate_pixmap;
+    scanout->pixmap = pixmap;
+    return TRUE;
+}
+
+static PixmapPtr
+drmmode_shadow_create(xf86CrtcPtr crtc, void *data, int width, int height)
+{
+    ScrnInfoPtr scrn = crtc->scrn;
+    drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
+
+    if (!data) {
+        data = drmmode_shadow_allocate(crtc, width, height);
+        if (!data) {
+            xf86DrvMsg(scrn->scrnIndex, X_ERROR,
+                       "Couldn't allocate shadow pixmap for rotated CRTC\n");
+            return NULL;
+        }
+    }
+
+    if (drmmode_scanout_pixmap_create(crtc, &drmmode_crtc->shadow_rotated))
+        return drmmode_crtc->shadow_rotated.pixmap;
+    else
+        return NULL;
 }
 
 static void
diff --git a/hw/xfree86/drivers/modesetting/drmmode_display.h b/hw/xfree86/drivers/modesetting/drmmode_display.h
index 499a95c39..48816b8b7 100644
--- a/hw/xfree86/drivers/modesetting/drmmode_display.h
+++ b/hw/xfree86/drivers/modesetting/drmmode_display.h
@@ -153,6 +153,7 @@ typedef struct {
 typedef struct {
     drmmode_bo bo;
     unsigned fb_id;
+    PixmapPtr pixmap;
 } drmmode_shadow_scanout_rec, *drmmode_shadow_scanout_ptr;
 
 typedef struct {
-- 
2.18.1


From ef26008dead94d697073313faea7c6ebee8d520f Mon Sep 17 00:00:00 2001
From: Martin Peres <martin.peres@linux.intel.com>
Date: Fri, 8 Jun 2018 18:41:50 +0300
Subject: [PATCH 03/11] modesetting: add damage tracking to the shadow scanouts

This allows to know what is the damaged part of the screen, in order to
limit the amount of data needing to be blitted to the shadow.

This change also introduces drmmode_update_scanout_buffer() which uses
the damage information to blit the parts that need to be updated.

Signed-off-by: Martin Peres <martin.peres@linux.intel.com>
---
 hw/xfree86/drivers/modesetting/driver.c       | 31 +++++++++++
 .../drivers/modesetting/drmmode_display.c     | 53 +++++++++++++++++++
 .../drivers/modesetting/drmmode_display.h     |  3 ++
 3 files changed, 87 insertions(+)

diff --git a/hw/xfree86/drivers/modesetting/driver.c b/hw/xfree86/drivers/modesetting/driver.c
index 8d29b130f..64908cce1 100644
--- a/hw/xfree86/drivers/modesetting/driver.c
+++ b/hw/xfree86/drivers/modesetting/driver.c
@@ -501,6 +501,34 @@ GetRec(ScrnInfoPtr pScrn)
     return TRUE;
 }
 
+static void
+ms_update_scanout_damages(ScrnInfoPtr scrn, DamagePtr damage)
+{
+    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
+    RegionPtr dmg_region = DamageRegion(damage);
+    int c;
+
+    for (c = 0; c < xf86_config->num_crtc; c++) {
+        xf86CrtcPtr crtc = xf86_config->crtc[c];
+        drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
+        RegionRec pixregion;
+
+        /* do not do any copies for inactive or rotated displays */
+        if (!crtc->active || !drmmode_crtc->shadow_nonrotated)
+            continue;
+
+        /* compute the intersection between the damaged region and the current
+         * crtc, then make the union of the current damages found for the
+         * current BO.
+         */
+        RegionInit(&pixregion, &crtc->bounds, 1);
+        RegionIntersect(&pixregion, &pixregion, dmg_region);
+        RegionUnion(&drmmode_crtc->shadow_nonrotated->screen_damage,
+                    &drmmode_crtc->shadow_nonrotated->screen_damage,
+                    &pixregion);
+    }
+}
+
 static int
 dispatch_dirty_region(ScrnInfoPtr scrn,
                       PixmapPtr pixmap, DamagePtr damage, int fb_id)
@@ -510,6 +538,9 @@ dispatch_dirty_region(ScrnInfoPtr scrn,
     unsigned num_cliprects = REGION_NUM_RECTS(dirty);
     int ret = 0;
 
+    /* per-crtc scanout damage tracking */
+    ms_update_scanout_damages(scrn, damage);
+
     if (num_cliprects) {
         drmModeClip *clip = xallocarray(num_cliprects, sizeof(drmModeClip));
         BoxPtr rect = REGION_RECTS(dirty);
diff --git a/hw/xfree86/drivers/modesetting/drmmode_display.c b/hw/xfree86/drivers/modesetting/drmmode_display.c
index b1d2cbffa..4c82e1b94 100644
--- a/hw/xfree86/drivers/modesetting/drmmode_display.c
+++ b/hw/xfree86/drivers/modesetting/drmmode_display.c
@@ -1293,6 +1293,54 @@ drmmode_DisableSharedPixmapFlipping(xf86CrtcPtr crtc, drmmode_ptr drmmode)
                                       &drmmode_crtc->prime_pixmap_back);
 }
 
+void
+drmmode_update_scanout_buffer(xf86CrtcPtr crtc, drmmode_shadow_scanout_ptr scanout)
+{
+    ScreenPtr pScreen = xf86ScrnToScreen(crtc->scrn);
+    PixmapPtr screenpix = pScreen->GetScreenPixmap(pScreen);
+    PixmapPtr dst = scanout->pixmap;
+    BoxPtr b;
+    GCPtr pGC;
+    int n;
+
+    /* early exit if we have nothing to do */
+    if (RegionNil(&scanout->screen_damage))
+        return;
+
+    n = RegionNumRects(&scanout->screen_damage);
+    b = RegionRects(&scanout->screen_damage);
+
+    pGC = GetScratchGC(crtc->scrn->depth, pScreen);
+    if (pScreen->root) {
+        ChangeGCVal subWindowMode;
+
+        subWindowMode.val = IncludeInferiors;
+        ChangeGC(NullClient, pGC, GCSubwindowMode, &subWindowMode);
+    }
+    ValidateGC(&dst->drawable, pGC);
+
+    while (n--) {
+        BoxRec src_box;
+        int s_x, s_y, w, h, d_x, d_y;
+
+        src_box = *b;
+        s_x = src_box.x1;
+        s_y = src_box.y1;
+        w = src_box.x2 - src_box.x1;
+        h = src_box.y2 - src_box.y1;
+        d_x = src_box.x1 - crtc->x;
+        d_y = src_box.y1 - crtc->y;
+
+        pGC->ops->CopyArea(&screenpix->drawable, &dst->drawable, pGC,
+                           s_x, s_y, w, h, d_x, d_y);
+        b++;
+    }
+    FreeScratchGC(pGC);
+
+    /* We have blitted all the damages, reset them */
+    RegionEmpty(&scanout->screen_damage);
+}
+
 static void
 drmmode_ConvertFromKMode(ScrnInfoPtr scrn,
                          drmModeModeInfo * kmode, DisplayModePtr mode)
@@ -1809,6 +1857,11 @@ drmmode_scanout_allocate(xf86CrtcPtr crtc, int width, int height,
         return FALSE;
     }
 
+    /* set the initial damage to the size of the CRTC since it has not been
+     * initialized yet.
+     */
+    RegionInit(&scanout->screen_damage, &crtc->bounds, 1);
+
     return TRUE;
 }
 
diff --git a/hw/xfree86/drivers/modesetting/drmmode_display.h b/hw/xfree86/drivers/modesetting/drmmode_display.h
index 48816b8b7..d3d42d920 100644
--- a/hw/xfree86/drivers/modesetting/drmmode_display.h
+++ b/hw/xfree86/drivers/modesetting/drmmode_display.h
@@ -154,6 +154,7 @@ typedef struct {
     drmmode_bo bo;
     unsigned fb_id;
     PixmapPtr pixmap;
+    RegionRec screen_damage;
 } drmmode_shadow_scanout_rec, *drmmode_shadow_scanout_ptr;
 
 typedef struct {
@@ -268,6 +269,8 @@ Bool drmmode_SharedPixmapFlip(PixmapPtr frontTarget, xf86CrtcPtr crtc,
                               drmmode_ptr drmmode);
 void drmmode_DisableSharedPixmapFlipping(xf86CrtcPtr crtc, drmmode_ptr drmmode);
 
+void drmmode_update_scanout_buffer(xf86CrtcPtr crtc, drmmode_shadow_scanout_ptr scanout);
+
 extern Bool drmmode_pre_init(ScrnInfoPtr pScrn, drmmode_ptr drmmode, int cpp);
 extern Bool drmmode_init(ScrnInfoPtr pScrn, drmmode_ptr drmmode);
 void drmmode_adjust_frame(ScrnInfoPtr pScrn, drmmode_ptr drmmode, int x, int y);
-- 
2.18.1


From 8156d6cbecb407372f9b43a1f186604cbd8e5f52 Mon Sep 17 00:00:00 2001
From: Martin Peres <martin.peres@linux.intel.com>
Date: Fri, 8 Jun 2018 18:54:20 +0300
Subject: [PATCH 04/11] modesetting: introduce the per-crtc shadow scanout

This code is currently disabled, but once enabled in future commits,
it will allocate a per-crtc shadow scanout buffer and copy the damages
found in the screen's pixmap.

Signed-off-by: Martin Peres <martin.peres@linux.intel.com>
---
 hw/xfree86/drivers/modesetting/driver.c       |  27 ++++
 .../drivers/modesetting/drmmode_display.c     | 116 ++++++++++++++++++
 .../drivers/modesetting/drmmode_display.h     |   1 +
 3 files changed, 144 insertions(+)

diff --git a/hw/xfree86/drivers/modesetting/driver.c b/hw/xfree86/drivers/modesetting/driver.c
index 64908cce1..244849c60 100644
--- a/hw/xfree86/drivers/modesetting/driver.c
+++ b/hw/xfree86/drivers/modesetting/driver.c
@@ -709,6 +709,30 @@ ms_dirty_get_ent(ScreenPtr screen, PixmapPtr slave_dst)
     return NULL;
 }
 
+static void
+ms_refresh_all_scanout_buffers(ScreenPtr pScreen)
+{
+    ScrnInfoPtr scrn = xf86ScreenToScrn(pScreen);
+    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
+    int c;
+
+    for (c = 0; c < xf86_config->num_crtc; c++) {
+        xf86CrtcPtr crtc = xf86_config->crtc[c];
+        drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
+
+        /* do not do any copies for inactive or rotated displays */
+        if (!crtc->active || !drmmode_crtc->shadow_nonrotated)
+            continue;
+
+        drmmode_update_scanout_buffer(crtc, drmmode_crtc->shadow_nonrotated);
+    }
+
+    /* force the buffer to be rendered to as quickly as possible */
+    #ifdef GLAMOR_HAS_GBM
+    glamor_finish(pScreen);
+    #endif
+}
+
 static void
 msBlockHandler(ScreenPtr pScreen, void *timeout)
 {
@@ -724,6 +748,9 @@ msBlockHandler(ScreenPtr pScreen, void *timeout)
         dispatch_dirty(pScreen);
 
     ms_dirty_update(pScreen, timeout);
+
+    /* TODO: limit the blits to the CRTC's refresh rate to save memory BW */
+    ms_refresh_all_scanout_buffers(pScreen);
 }
 
 static void
diff --git a/hw/xfree86/drivers/modesetting/drmmode_display.c b/hw/xfree86/drivers/modesetting/drmmode_display.c
index 4c82e1b94..284c1ca60 100644
--- a/hw/xfree86/drivers/modesetting/drmmode_display.c
+++ b/hw/xfree86/drivers/modesetting/drmmode_display.c
@@ -57,6 +57,13 @@ static Bool drmmode_xf86crtc_resize(ScrnInfoPtr scrn, int width, int height);
 static PixmapPtr drmmode_create_pixmap_header(ScreenPtr pScreen, int width, int height,
                                               int depth, int bitsPerPixel, int devKind,
                                               void *pPixData);
+static Bool
+drmmode_scanout_allocate(xf86CrtcPtr crtc, int width, int height,
+                         drmmode_shadow_scanout_ptr scanout);
+static Bool
+drmmode_scanout_pixmap_create(xf86CrtcPtr crtc, drmmode_shadow_scanout_ptr scanout);
+static void
+drmmode_scanout_destroy(xf86CrtcPtr crtc, drmmode_shadow_scanout_ptr scanout);
 
 static inline uint32_t *
 formats_ptr(struct drm_format_modifier_blob *blob)
@@ -619,6 +626,9 @@ drmmode_crtc_get_fb_id(xf86CrtcPtr crtc, uint32_t *fb_id, int *x, int *y)
     else if (drmmode_crtc->shadow_rotated.fb_id) {
         *fb_id = drmmode_crtc->shadow_rotated.fb_id;
         *x = *y = 0;
+    } else if (drmmode_crtc->shadow_nonrotated) {
+        *fb_id = drmmode_crtc->shadow_nonrotated->fb_id;
+        *x = *y = 0;
     }
     else {
         *fb_id = drmmode->fb_id;
@@ -1505,6 +1515,54 @@ drmmode_copy_fb(ScrnInfoPtr pScrn, drmmode_ptr drmmode)
 #endif
 }
 
+static drmmode_shadow_scanout_ptr
+drmmode_shadow_scanout_create(xf86CrtcPtr crtc)
+{
+    ScreenPtr screen = xf86ScrnToScreen(crtc->scrn);
+    ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
+    drmmode_shadow_scanout_ptr scanout;
+
+    scanout = calloc(sizeof(drmmode_shadow_scanout_rec), 1);
+    if (!scanout) {
+        xf86DrvMsg(scrn->scrnIndex, X_INFO,
+                   "failed to allocate a drmmode_shadow_scanout_rec struct\n");
+        return NULL;
+    }
+
+    if (!drmmode_scanout_allocate(crtc, crtc->mode.HDisplay,
+                                 crtc->mode.VDisplay,
+                                 scanout)) {
+        xf86DrvMsg(scrn->scrnIndex, X_INFO,
+                   "failed to allocate a %ix%i buffer\n",
+                   crtc->mode.HDisplay, crtc->mode.VDisplay);
+        free(scanout);
+        return NULL;
+    }
+
+    if (!drmmode_scanout_pixmap_create(crtc, scanout)) {
+        xf86DrvMsg(scrn->scrnIndex, X_INFO,
+                   "failed to create the scanout pixmap\n");
+        drmmode_scanout_destroy(crtc, scanout);
+        free(scanout);
+        return NULL;
+    }
+
+    /* force a repaint, to guarantee the initial state to be acceptable */
+    drmmode_update_scanout_buffer(crtc, scanout);
+
+    return scanout;
+}
+
+static Bool
+drmmode_need_shadow_scanout(xf86CrtcPtr crtc) {
+    /* we do not support rotated shadow because X already does */
+    if (crtc->rotation != RR_Rotate_0)
+        return FALSE;
+
+    /* We found no reason to shadow the FB, nothing else to do! */
+    return FALSE;
+}
+
 static Bool
 drmmode_set_mode_major(xf86CrtcPtr crtc, DisplayModePtr mode,
                        Rotation rotation, int x, int y)
@@ -1513,6 +1571,7 @@ drmmode_set_mode_major(xf86CrtcPtr crtc, DisplayModePtr mode,
     xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(crtc->scrn);
     drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
     drmmode_ptr drmmode = drmmode_crtc->drmmode;
+    drmmode_shadow_scanout_ptr saved_shadow_nonrotated;
     int saved_x, saved_y;
     Rotation saved_rotation;
     DisplayModeRec saved_mode;
@@ -1524,6 +1583,7 @@ drmmode_set_mode_major(xf86CrtcPtr crtc, DisplayModePtr mode,
     saved_x = crtc->x;
     saved_y = crtc->y;
     saved_rotation = crtc->rotation;
+    saved_shadow_nonrotated = drmmode_crtc->shadow_nonrotated;
 
     if (mode) {
         crtc->mode = *mode;
@@ -1538,6 +1598,18 @@ drmmode_set_mode_major(xf86CrtcPtr crtc, DisplayModePtr mode,
         crtc->funcs->gamma_set(crtc, crtc->gamma_red, crtc->gamma_green,
                                crtc->gamma_blue, crtc->gamma_size);
 
+        if (drmmode_need_shadow_scanout(crtc)) {
+            drmmode_crtc->shadow_nonrotated = drmmode_shadow_scanout_create(crtc);
+            if (!drmmode_crtc->shadow_nonrotated) {
+                xf86DrvMsg(crtc->scrn->scrnIndex, X_ERROR,
+                           "drmmode_scanout_shadow_init failed!\n");
+                ret = FALSE;
+                goto done;
+            }
+        } else {
+            drmmode_crtc->shadow_nonrotated = NULL;
+        }
+
         can_test = drmmode_crtc_can_test_mode(crtc);
         if (drmmode_crtc_set_mode(crtc, can_test)) {
             xf86DrvMsg(crtc->scrn->scrnIndex, X_ERROR,
@@ -1547,6 +1619,9 @@ drmmode_set_mode_major(xf86CrtcPtr crtc, DisplayModePtr mode,
         } else
             ret = TRUE;
 
+        /* We cannot fail anymore, free the previous scanout buffer */
+        drmmode_scanout_destroy(crtc, saved_shadow_nonrotated);
+
         if (crtc->scrn->pScreen)
             xf86CrtcSetScreenSubpixelOrder(crtc->scrn->pScreen);
 
@@ -1583,6 +1658,12 @@ drmmode_set_mode_major(xf86CrtcPtr crtc, DisplayModePtr mode,
         crtc->y = saved_y;
         crtc->rotation = saved_rotation;
         crtc->mode = saved_mode;
+
+        /* make sure we de-allocate anything we may have allocated before
+         * restoring the previous values
+         */
+        drmmode_scanout_destroy(crtc, drmmode_crtc->shadow_nonrotated);
+        drmmode_crtc->shadow_nonrotated = saved_shadow_nonrotated;
     } else
         crtc->active = TRUE;
 
@@ -1967,6 +2048,33 @@ drmmode_shadow_create(xf86CrtcPtr crtc, void *data, int width, int height)
         return NULL;
 }
 
+static void
+drmmode_scanout_destroy(xf86CrtcPtr crtc, drmmode_shadow_scanout_ptr scanout)
+{
+    drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
+    drmmode_ptr drmmode = drmmode_crtc->drmmode;
+
+    if (!scanout)
+        return;
+
+    if (scanout->pixmap) {
+        scanout->pixmap->drawable.pScreen->DestroyPixmap(scanout->pixmap);
+        scanout->pixmap = NULL;
+    }
+
+    if (scanout->fb_id) {
+        drmModeRmFB(drmmode->fd, scanout->fb_id);
+        scanout->fb_id = 0;
+    }
+
+    drmmode_bo_destroy(drmmode, &scanout->bo);
+    memset(&scanout->bo, 0, sizeof scanout->bo);
+
+    RegionEmpty(&scanout->screen_damage);
+
+    free(scanout);
+}
+
 static void
 drmmode_shadow_destroy(xf86CrtcPtr crtc, PixmapPtr rotate_pixmap, void *data)
 {
@@ -3933,6 +4041,14 @@ drmmode_free_bos(ScrnInfoPtr pScrn, drmmode_ptr drmmode)
         drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
 
         dumb_bo_destroy(drmmode->fd, drmmode_crtc->cursor_bo);
+
+        drmmode_scanout_destroy(crtc, drmmode_crtc->shadow_nonrotated);
+
+        /* HACK: make sure the shadow buffers are NULL because, when reseting, X
+         * does not re-allocate the crtc structures, which keeps stale pointers
+         * and leads to some use-after-free.
+         */
+        drmmode_crtc->shadow_nonrotated = NULL;
     }
 }
 
diff --git a/hw/xfree86/drivers/modesetting/drmmode_display.h b/hw/xfree86/drivers/modesetting/drmmode_display.h
index d3d42d920..c861691d2 100644
--- a/hw/xfree86/drivers/modesetting/drmmode_display.h
+++ b/hw/xfree86/drivers/modesetting/drmmode_display.h
@@ -174,6 +174,7 @@ typedef struct {
     drmmode_format_rec *formats;
 
     drmmode_shadow_scanout_rec shadow_rotated;
+    drmmode_shadow_scanout_ptr shadow_nonrotated;
 
     PixmapPtr prime_pixmap;
     PixmapPtr prime_pixmap_back;
-- 
2.18.1


From af97f2a5e4e73ac2763b1efced3848bdb6a3f7ff Mon Sep 17 00:00:00 2001
From: Martin Peres <martin.peres@linux.intel.com>
Date: Fri, 8 Jun 2018 19:08:05 +0300
Subject: [PATCH 05/11] modesetting: use per-crtc scanout BOs when exceeding
 DRM limitations

When the user wants to make his/her screen larger than what the DRM
driver allows, let it happen by using the per-crtc framebuffers and
warn about this in the logs, including about the performance loss.

Signed-off-by: Martin Peres <martin.peres@linux.intel.com>
---
 .../drivers/modesetting/drmmode_display.c     | 34 +++++++++++++++++--
 1 file changed, 32 insertions(+), 2 deletions(-)

diff --git a/hw/xfree86/drivers/modesetting/drmmode_display.c b/hw/xfree86/drivers/modesetting/drmmode_display.c
index 284c1ca60..5ce3ff2f4 100644
--- a/hw/xfree86/drivers/modesetting/drmmode_display.c
+++ b/hw/xfree86/drivers/modesetting/drmmode_display.c
@@ -1555,10 +1555,41 @@ drmmode_shadow_scanout_create(xf86CrtcPtr crtc)
 
 static Bool
 drmmode_need_shadow_scanout(xf86CrtcPtr crtc) {
+    drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
+    drmmode_ptr drmmode = drmmode_crtc->drmmode;
+    ScreenPtr pScreen = xf86ScrnToScreen(crtc->scrn);
+    PixmapPtr screenpix = pScreen->GetScreenPixmap(pScreen);
+    drmModeResPtr mode_res;
+
     /* we do not support rotated shadow because X already does */
     if (crtc->rotation != RR_Rotate_0)
         return FALSE;
 
+    /* check if the current screen size exceeds the driver's limits */
+    mode_res = drmModeGetResources(drmmode->fd);
+    if (!mode_res)
+        return FALSE;
+
+    if (screenpix->drawable.width >= mode_res->max_width) {
+        xf86DrvMsg(crtc->scrn->scrnIndex, X_ERROR,
+                   "Shadow the CRTC's scanout buffer because the screen width "
+                   "exceeds the driver's limit (%d vs %d). Expect a lower"
+                   "performance. Use the XRender backend of your compositor "
+                   "to reduce the performance impact.\n",
+                   screenpix->drawable.width, mode_res->max_width);
+        return TRUE;
+    }
+
+    if (screenpix->drawable.height >= mode_res->max_height) {
+        xf86DrvMsg(crtc->scrn->scrnIndex, X_ERROR,
+                   "Shadow the CRTC's scanout buffer because the screen height "
+                   "exceeds the driver's limit (%d vs %d). Expect a lower lower"
+                   "performance. Use the XRender backend of your compositor "
+                   "to reduce the performance impact.\n",
+                   screenpix->drawable.height, mode_res->max_height);
+        return TRUE;
+    }
+
     /* We found no reason to shadow the FB, nothing else to do! */
     return FALSE;
 }
@@ -3560,8 +3591,7 @@ drmmode_pre_init(ScrnInfoPtr pScrn, drmmode_ptr drmmode, int cpp)
     xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, MS_LOGLEVEL_DEBUG,
                    "Up to %d crtcs needed for screen.\n", crtcs_needed);
 
-    xf86CrtcSetSizeRange(pScrn, 320, 200, mode_res->max_width,
-                         mode_res->max_height);
+    xf86CrtcSetSizeRange(pScrn, 320, 200, INT16_MAX, INT16_MAX);
     for (i = 0; i < mode_res->count_crtcs; i++)
         if (!xf86IsEntityShared(pScrn->entityList[0]) ||
             (crtcs_needed && !(ms_ent->assigned_crtcs & (1 << i))))
-- 
2.18.1


From 46a2577d6d87452669cd89d51be84d46d8dfff72 Mon Sep 17 00:00:00 2001
From: Martin Peres <martin.peres@linux.intel.com>
Date: Tue, 12 Jun 2018 12:12:27 +0300
Subject: [PATCH 06/11] modesetting: handle scanout damages at the crtc's
 refresh rate

This is not giving us tear-free, but we are getting close to it!

Signed-off-by: Martin Peres <martin.peres@linux.intel.com>
---
 hw/xfree86/drivers/modesetting/driver.c       | 17 +++--
 .../drivers/modesetting/drmmode_display.c     | 64 +++++++++++++++++++
 .../drivers/modesetting/drmmode_display.h     |  3 +
 3 files changed, 75 insertions(+), 9 deletions(-)

diff --git a/hw/xfree86/drivers/modesetting/driver.c b/hw/xfree86/drivers/modesetting/driver.c
index 244849c60..5cb8615ca 100644
--- a/hw/xfree86/drivers/modesetting/driver.c
+++ b/hw/xfree86/drivers/modesetting/driver.c
@@ -710,7 +710,7 @@ ms_dirty_get_ent(ScreenPtr screen, PixmapPtr slave_dst)
 }
 
 static void
-ms_refresh_all_scanout_buffers(ScreenPtr pScreen)
+ms_schedule_all_scanout_buffers_updates(ScreenPtr pScreen)
 {
     ScrnInfoPtr scrn = xf86ScreenToScrn(pScreen);
     xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
@@ -724,13 +724,13 @@ ms_refresh_all_scanout_buffers(ScreenPtr pScreen)
         if (!crtc->active || !drmmode_crtc->shadow_nonrotated)
             continue;
 
-        drmmode_update_scanout_buffer(crtc, drmmode_crtc->shadow_nonrotated);
+        /* schedule an async update, or revert to a synchronous copy on failure */
+        if (!drmmode_scanout_buffer_update_schedule(crtc,
+                                                    drmmode_crtc->shadow_nonrotated)) {
+            drmmode_update_scanout_buffer(crtc,
+                                          drmmode_crtc->shadow_nonrotated);
+        }
     }
-
-    /* force the buffer to be rendered to as quickly as possible */
-    #ifdef GLAMOR_HAS_GBM
-    glamor_finish(pScreen);
-    #endif
 }
 
 static void
@@ -749,8 +749,7 @@ msBlockHandler(ScreenPtr pScreen, void *timeout)
 
     ms_dirty_update(pScreen, timeout);
 
-    /* TODO: limit the blits to the CRTC's refresh rate to save memory BW */
-    ms_refresh_all_scanout_buffers(pScreen);
+    ms_schedule_all_scanout_buffers_updates(pScreen);
 }
 
 static void
diff --git a/hw/xfree86/drivers/modesetting/drmmode_display.c b/hw/xfree86/drivers/modesetting/drmmode_display.c
index 5ce3ff2f4..623e72c6a 100644
--- a/hw/xfree86/drivers/modesetting/drmmode_display.c
+++ b/hw/xfree86/drivers/modesetting/drmmode_display.c
@@ -1349,8 +1349,67 @@ drmmode_update_scanout_buffer(xf86CrtcPtr crtc, drmmode_shadow_scanout_ptr scano
 
     /* We have blitted all the damages, reset them */
     RegionEmpty(&scanout->screen_damage);
+
+    /* force the buffer to be rendered to as quickly as possible */
+    #ifdef GLAMOR_HAS_GBM
+    glamor_finish(pScreen);
+    #endif
 }
 
+struct scanout_buffer_update_args {
+    xf86CrtcPtr crtc;
+    drmmode_shadow_scanout_ptr scanout;
+};
+
+static void
+drmmode_scanout_buffer_update_handler(uint64_t frame, uint64_t usec,
+                                      void *data)
+{
+    struct scanout_buffer_update_args *args = data;
+
+    if (args->scanout) {
+        drmmode_update_scanout_buffer(args->crtc, args->scanout);
+    }
+    args->scanout->update_seq = 0;
+    free(args);
+}
+
+static void
+drmmode_scanout_buffer_update_abort(void *data)
+{
+    struct scanout_buffer_update_args *args = data;
+    args->scanout->update_seq = 0;
+    free(args);
+}
+
+Bool
+drmmode_scanout_buffer_update_schedule(xf86CrtcPtr crtc,
+                                       drmmode_shadow_scanout_ptr scanout)
+{
+    struct scanout_buffer_update_args *event_args;
+    int flip_seq = 0, ret;
+
+    if (scanout->update_seq)
+        return TRUE;
+
+    event_args = calloc(1, sizeof(*event_args));
+    if (!event_args)
+        return FALSE;
+
+    event_args->crtc = crtc;
+    event_args->scanout = scanout;
+
+    flip_seq = ms_drm_queue_alloc(crtc, event_args,
+                                  drmmode_scanout_buffer_update_handler,
+                                  drmmode_scanout_buffer_update_abort);
+
+    ret = ms_queue_vblank(crtc, MS_QUEUE_RELATIVE, 1, NULL, flip_seq);
+    scanout->update_seq = ret ? flip_seq : 0;
+
+    return ret;
+}
+
+
 static void
 drmmode_ConvertFromKMode(ScrnInfoPtr scrn,
                          drmModeModeInfo * kmode, DisplayModePtr mode)
@@ -2088,6 +2147,11 @@ drmmode_scanout_destroy(xf86CrtcPtr crtc, drmmode_shadow_scanout_ptr scanout)
     if (!scanout)
         return;
 
+    if (scanout->update_seq) {
+        ms_drm_abort_seq(crtc->scrn, scanout->update_seq);
+        scanout->update_seq = 0;
+    }
+
     if (scanout->pixmap) {
         scanout->pixmap->drawable.pScreen->DestroyPixmap(scanout->pixmap);
         scanout->pixmap = NULL;
diff --git a/hw/xfree86/drivers/modesetting/drmmode_display.h b/hw/xfree86/drivers/modesetting/drmmode_display.h
index c861691d2..184b4bb90 100644
--- a/hw/xfree86/drivers/modesetting/drmmode_display.h
+++ b/hw/xfree86/drivers/modesetting/drmmode_display.h
@@ -155,6 +155,7 @@ typedef struct {
     unsigned fb_id;
     PixmapPtr pixmap;
     RegionRec screen_damage;
+    uint32_t update_seq;
 } drmmode_shadow_scanout_rec, *drmmode_shadow_scanout_ptr;
 
 typedef struct {
@@ -271,6 +272,8 @@ Bool drmmode_SharedPixmapFlip(PixmapPtr frontTarget, xf86CrtcPtr crtc,
 void drmmode_DisableSharedPixmapFlipping(xf86CrtcPtr crtc, drmmode_ptr drmmode);
 
 void drmmode_update_scanout_buffer(xf86CrtcPtr crtc, drmmode_shadow_scanout_ptr scanout);
+Bool drmmode_scanout_buffer_update_schedule(xf86CrtcPtr crtc,
+                                            drmmode_shadow_scanout_ptr scanout);
 
 extern Bool drmmode_pre_init(ScrnInfoPtr pScrn, drmmode_ptr drmmode, int cpp);
 extern Bool drmmode_init(ScrnInfoPtr pScrn, drmmode_ptr drmmode);
-- 
2.18.1


From 2bf9dca64ebf7b01779554c76b977dda48114039 Mon Sep 17 00:00:00 2001
From: Martin Peres <martin.peres@linux.intel.com>
Date: Fri, 8 Jun 2018 19:11:35 +0300
Subject: [PATCH 07/11] modesetting: add an option to force-enable per-crtc
 shadow buffers

This allows us to validate that this codepath is still working
properly, without requiring adding tons of displays and separating
them enough to hit the maximum stride of the display.

Signed-off-by: Martin Peres <martin.peres@linux.intel.com>
---
 hw/xfree86/drivers/modesetting/driver.c          |  8 ++++++++
 hw/xfree86/drivers/modesetting/driver.h          |  1 +
 hw/xfree86/drivers/modesetting/drmmode_display.c |  3 +++
 hw/xfree86/drivers/modesetting/drmmode_display.h |  3 +++
 hw/xfree86/drivers/modesetting/modesetting.man   | 13 +++++++++++++
 5 files changed, 28 insertions(+)

diff --git a/hw/xfree86/drivers/modesetting/driver.c b/hw/xfree86/drivers/modesetting/driver.c
index 5cb8615ca..d0c764e3e 100644
--- a/hw/xfree86/drivers/modesetting/driver.c
+++ b/hw/xfree86/drivers/modesetting/driver.c
@@ -131,6 +131,7 @@ static const OptionInfoRec Options[] = {
     {OPTION_PAGEFLIP, "PageFlip", OPTV_BOOLEAN, {0}, FALSE},
     {OPTION_ZAPHOD_HEADS, "ZaphodHeads", OPTV_STRING, {0}, FALSE},
     {OPTION_DOUBLE_SHADOW, "DoubleShadow", OPTV_BOOLEAN, {0}, FALSE},
+    {OPTION_SHADOW_PRIMARY, "ShadowPrimary", OPTV_BOOLEAN, {0}, FALSE},
     {-1, NULL, OPTV_NONE, {0}, FALSE}
 };
 
@@ -1039,6 +1040,13 @@ PreInit(ScrnInfoPtr pScrn, int flags)
         ms->drmmode.sw_cursor = TRUE;
     }
 
+    ms->drmmode.shadow_primary =
+            xf86ReturnOptValBool(ms->drmmode.Options, OPTION_SHADOW_PRIMARY,
+                                 FALSE);
+    if (ms->drmmode.shadow_primary) {
+        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ShadowPrimary enabled\n");
+    }
+
     ms->cursor_width = 64;
     ms->cursor_height = 64;
     ret = drmGetCap(ms->fd, DRM_CAP_CURSOR_WIDTH, &value);
diff --git a/hw/xfree86/drivers/modesetting/driver.h b/hw/xfree86/drivers/modesetting/driver.h
index c8db4b8a4..1307180dd 100644
--- a/hw/xfree86/drivers/modesetting/driver.h
+++ b/hw/xfree86/drivers/modesetting/driver.h
@@ -51,6 +51,7 @@ typedef enum {
     OPTION_PAGEFLIP,
     OPTION_ZAPHOD_HEADS,
     OPTION_DOUBLE_SHADOW,
+    OPTION_SHADOW_PRIMARY,
 } modesettingOpts;
 
 typedef struct
diff --git a/hw/xfree86/drivers/modesetting/drmmode_display.c b/hw/xfree86/drivers/modesetting/drmmode_display.c
index 623e72c6a..d292db3c5 100644
--- a/hw/xfree86/drivers/modesetting/drmmode_display.c
+++ b/hw/xfree86/drivers/modesetting/drmmode_display.c
@@ -1624,6 +1624,9 @@ drmmode_need_shadow_scanout(xf86CrtcPtr crtc) {
     if (crtc->rotation != RR_Rotate_0)
         return FALSE;
 
+    if (drmmode->shadow_primary)
+        return TRUE;
+
     /* check if the current screen size exceeds the driver's limits */
     mode_res = drmModeGetResources(drmmode->fd);
     if (!mode_res)
diff --git a/hw/xfree86/drivers/modesetting/drmmode_display.h b/hw/xfree86/drivers/modesetting/drmmode_display.h
index 184b4bb90..c6a48a56d 100644
--- a/hw/xfree86/drivers/modesetting/drmmode_display.h
+++ b/hw/xfree86/drivers/modesetting/drmmode_display.h
@@ -104,6 +104,9 @@ typedef struct {
     Bool glamor;
     Bool shadow_enable;
     Bool shadow_enable2;
+    /** force creating a per-crtc framebuffer **/
+    Bool shadow_primary;
+
     /** Is Option "PageFlip" enabled? */
     Bool pageflip;
     Bool force_24_32;
diff --git a/hw/xfree86/drivers/modesetting/modesetting.man b/hw/xfree86/drivers/modesetting/modesetting.man
index d530d7c4c..abf450c7c 100644
--- a/hw/xfree86/drivers/modesetting/modesetting.man
+++ b/hw/xfree86/drivers/modesetting/modesetting.man
@@ -81,6 +81,19 @@ For example:
 Option \*qZaphodHeads\*q \*qLVDS,VGA-0\*q
 will assign xrandr outputs LVDS and VGA-0 to this instance of the driver.
 .TP
+.BI "Option \*qShadowPrimary\*q \*q" boolean \*q
+This option enables a so-called "shadow primary" buffer for fast CPU access to
+pixel data, and separate scanout buffers for each display controller (CRTC).
+This may improve performance for some 2D workloads, potentially at the expense
+of other (e.g. 3D, video) workloads. This option may be enabled automatically
+when the root window size exceeds the maximum stride supported by the display
+controler of your GPU. It is recommended to use the XRender backend of your
+compositor when enabling this feature.
+.br
+In an effort to reduce the performance cost, the latency may be negatively
+affected. The default is
+.B off.
+.TP
 .SH "SEE ALSO"
 @xservername@(@appmansuffix@), @xconfigfile@(@filemansuffix@), Xserver(@appmansuffix@),
 X(@miscmansuffix@)
-- 
2.18.1


From de9ef18d9adb3f14baaae241ddb03ede93c63506 Mon Sep 17 00:00:00 2001
From: Martin Peres <martin.peres@linux.intel.com>
Date: Wed, 19 Sep 2018 15:04:21 +0300
Subject: [PATCH 08/11] modesetting/pageflip: make do_queue_flip_on_crtc() more
 generic

This function was really just a way to cast one variable and was used
in a single function, which was itself doing the flush_drm_event on
error.

With this patch, this function is now hiding the nasty loop into it,
to make it easy to re-use. We'll use it in a later patch.

Signed-off-by: Martin Peres <martin.peres@linux.intel.com>
---
 hw/xfree86/drivers/modesetting/pageflip.c | 50 +++++++++++++----------
 1 file changed, 28 insertions(+), 22 deletions(-)

diff --git a/hw/xfree86/drivers/modesetting/pageflip.c b/hw/xfree86/drivers/modesetting/pageflip.c
index 9667f132d..027289f4e 100644
--- a/hw/xfree86/drivers/modesetting/pageflip.c
+++ b/hw/xfree86/drivers/modesetting/pageflip.c
@@ -160,11 +160,30 @@ ms_pageflip_abort(void *data)
 }
 
 static Bool
-do_queue_flip_on_crtc(modesettingPtr ms, xf86CrtcPtr crtc,
+do_queue_flip_on_crtc(ScreenPtr screen, xf86CrtcPtr crtc, unsigned int fb_id,
                       uint32_t flags, uint32_t seq)
 {
-    return drmmode_crtc_flip(crtc, ms->drmmode.fb_id, flags,
-                             (void *) (uintptr_t) seq);
+    ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
+    int err;
+
+    while (drmmode_crtc_flip(crtc, fb_id, flags, (void *) (uintptr_t) seq)) {
+        err = errno;
+        /* We may have failed because the event queue was full.  Flush it
+         * and retry.  If there was nothing to flush, then we failed for
+         * some other reason and should just return an error.
+         */
+        if (ms_flush_drm_events(screen) <= 0) {
+            xf86DrvMsg(scrn->scrnIndex, X_WARNING,
+                       "flip queue failed: %s\n", strerror(err));
+            return FALSE;
+        }
+
+        /* We flushed some events, so try again. */
+        xf86DrvMsg(scrn->scrnIndex, X_WARNING, "flip queue retry\n");
+    }
+
+    /* The page flip succeded. */
+    return TRUE;
 }
 
 static Bool
@@ -177,7 +196,7 @@ queue_flip_on_crtc(ScreenPtr screen, xf86CrtcPtr crtc,
     drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
     struct ms_crtc_pageflip *flip;
     uint32_t seq;
-    int err;
+    Bool ret;
 
     flip = calloc(1, sizeof(struct ms_crtc_pageflip));
     if (flip == NULL) {
@@ -201,26 +220,13 @@ queue_flip_on_crtc(ScreenPtr screen, xf86CrtcPtr crtc,
     /* take a reference on flipdata for use in flip */
     flipdata->flip_count++;
 
-    while (do_queue_flip_on_crtc(ms, crtc, flags, seq)) {
-        err = errno;
-        /* We may have failed because the event queue was full.  Flush it
-         * and retry.  If there was nothing to flush, then we failed for
-         * some other reason and should just return an error.
-         */
-        if (ms_flush_drm_events(screen) <= 0) {
-            xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-                       "flip queue failed: %s\n", strerror(err));
-            /* Aborting will also decrement flip_count and free(flip). */
-            ms_drm_abort_seq(scrn, seq);
-            return FALSE;
-        }
-
-        /* We flushed some events, so try again. */
-        xf86DrvMsg(scrn->scrnIndex, X_WARNING, "flip queue retry\n");
+    ret = do_queue_flip_on_crtc(screen, crtc, ms->drmmode.fb_id, flags, seq);
+    if (!ret) {
+        /* Aborting will also decrement flip_count and free(flip). */
+        ms_drm_abort_seq(scrn, seq);
     }
 
-    /* The page flip succeded. */
-    return TRUE;
+    return ret;
 }
 
 
-- 
2.18.1


From 981499c8b5003eadd55a79405cb389521c6bde77 Mon Sep 17 00:00:00 2001
From: Martin Peres <martin.peres@linux.intel.com>
Date: Wed, 19 Sep 2018 15:49:42 +0300
Subject: [PATCH 09/11] modesetting/drmmode_crtc_flip: get the x/y offets from
 the current fb

This allows the flip to happen on per-crtc framebuffers.

Signed-off-by: Martin Peres <martin.peres@linux.intel.com>
---
 hw/xfree86/drivers/modesetting/drmmode_display.c | 10 ++++++++--
 1 file changed, 8 insertions(+), 2 deletions(-)

diff --git a/hw/xfree86/drivers/modesetting/drmmode_display.c b/hw/xfree86/drivers/modesetting/drmmode_display.c
index d292db3c5..98ca3b2e2 100644
--- a/hw/xfree86/drivers/modesetting/drmmode_display.c
+++ b/hw/xfree86/drivers/modesetting/drmmode_display.c
@@ -870,7 +870,8 @@ drmmode_crtc_flip(xf86CrtcPtr crtc, uint32_t fb_id, uint32_t flags, void *data)
 {
     modesettingPtr ms = modesettingPTR(crtc->scrn);
     drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
-    int ret;
+    uint32_t fb_id_tmp;
+    int x, y, ret;
 
     if (ms->atomic_modeset) {
         drmModeAtomicReq *req = drmModeAtomicAlloc();
@@ -878,7 +879,12 @@ drmmode_crtc_flip(xf86CrtcPtr crtc, uint32_t fb_id, uint32_t flags, void *data)
         if (!req)
             return 1;
 
-        ret = plane_add_props(req, crtc, fb_id, crtc->x, crtc->y);
+        /* get the x/y positions that need to be used for the flip based on the
+         * current scanout fb.
+         */
+        drmmode_crtc_get_fb_id(crtc, &fb_id_tmp, &x, &y);
+
+        ret = plane_add_props(req, crtc, fb_id, x, y);
         flags |= DRM_MODE_ATOMIC_NONBLOCK;
         if (ret == 0)
             ret = drmModeAtomicCommit(ms->fd, req, flags, data);
-- 
2.18.1


From f5cd9357855b62421f91d021f5d5e31e7238701f Mon Sep 17 00:00:00 2001
From: Martin Peres <martin.peres@linux.intel.com>
Date: Wed, 19 Sep 2018 15:57:12 +0300
Subject: [PATCH 10/11] modesetting: add TearFree support

All this work to get there, now enjoy your tear-free desktop!

Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=102508
Signed-off-by: Martin Peres <martin.peres@linux.intel.com>
---
 hw/xfree86/drivers/modesetting/driver.c       | 31 ++++++++--
 hw/xfree86/drivers/modesetting/driver.h       |  2 +
 .../drivers/modesetting/drmmode_display.c     | 26 ++++++--
 .../drivers/modesetting/drmmode_display.h     |  4 ++
 .../drivers/modesetting/modesetting.man       |  8 +++
 hw/xfree86/drivers/modesetting/pageflip.c     | 61 +++++++++++++++++++
 6 files changed, 123 insertions(+), 9 deletions(-)

diff --git a/hw/xfree86/drivers/modesetting/driver.c b/hw/xfree86/drivers/modesetting/driver.c
index d0c764e3e..78909ac02 100644
--- a/hw/xfree86/drivers/modesetting/driver.c
+++ b/hw/xfree86/drivers/modesetting/driver.c
@@ -132,6 +132,7 @@ static const OptionInfoRec Options[] = {
     {OPTION_ZAPHOD_HEADS, "ZaphodHeads", OPTV_STRING, {0}, FALSE},
     {OPTION_DOUBLE_SHADOW, "DoubleShadow", OPTV_BOOLEAN, {0}, FALSE},
     {OPTION_SHADOW_PRIMARY, "ShadowPrimary", OPTV_BOOLEAN, {0}, FALSE},
+    {OPTION_TEARFREE, "TearFree", OPTV_BOOLEAN, {0}, FALSE},
     {-1, NULL, OPTV_NONE, {0}, FALSE}
 };
 
@@ -527,6 +528,13 @@ ms_update_scanout_damages(ScrnInfoPtr scrn, DamagePtr damage)
         RegionUnion(&drmmode_crtc->shadow_nonrotated->screen_damage,
                     &drmmode_crtc->shadow_nonrotated->screen_damage,
                     &pixregion);
+
+        /* also update the shadow backbuffer's damages if available */
+        if (drmmode_crtc->shadow_nonrotated_back) {
+            RegionUnion(&drmmode_crtc->shadow_nonrotated_back->screen_damage,
+                        &drmmode_crtc->shadow_nonrotated_back->screen_damage,
+                        &pixregion);
+        }
     }
 }
 
@@ -720,16 +728,22 @@ ms_schedule_all_scanout_buffers_updates(ScreenPtr pScreen)
     for (c = 0; c < xf86_config->num_crtc; c++) {
         xf86CrtcPtr crtc = xf86_config->crtc[c];
         drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
+        drmmode_ptr drmmode = drmmode_crtc->drmmode;
 
         /* do not do any copies for inactive or rotated displays */
         if (!crtc->active || !drmmode_crtc->shadow_nonrotated)
             continue;
 
-        /* schedule an async update, or revert to a synchronous copy on failure */
-        if (!drmmode_scanout_buffer_update_schedule(crtc,
-                                                    drmmode_crtc->shadow_nonrotated)) {
-            drmmode_update_scanout_buffer(crtc,
-                                          drmmode_crtc->shadow_nonrotated);
+        /* do an async update, unless we are using tearfree or if it failed */
+        if (drmmode->tear_free) {
+            ms_do_tearfree_flip(crtc);
+        } else if (!drmmode_scanout_buffer_update_schedule(crtc,
+                                                           drmmode_crtc->shadow_nonrotated)) {
+                /* since we failed the asynchronous update, fallback to the
+                 * synchronous one
+                 */
+                drmmode_update_scanout_buffer(crtc,
+                                              drmmode_crtc->shadow_nonrotated);
         }
     }
 }
@@ -1047,6 +1061,13 @@ PreInit(ScrnInfoPtr pScrn, int flags)
         xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ShadowPrimary enabled\n");
     }
 
+    ms->drmmode.tear_free =
+            xf86ReturnOptValBool(ms->drmmode.Options, OPTION_TEARFREE,
+                                 FALSE);
+    if (ms->drmmode.tear_free) {
+        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "TearFree enabled\n");
+    }
+
     ms->cursor_width = 64;
     ms->cursor_height = 64;
     ret = drmGetCap(ms->fd, DRM_CAP_CURSOR_WIDTH, &value);
diff --git a/hw/xfree86/drivers/modesetting/driver.h b/hw/xfree86/drivers/modesetting/driver.h
index 1307180dd..237c54f6a 100644
--- a/hw/xfree86/drivers/modesetting/driver.h
+++ b/hw/xfree86/drivers/modesetting/driver.h
@@ -52,6 +52,7 @@ typedef enum {
     OPTION_ZAPHOD_HEADS,
     OPTION_DOUBLE_SHADOW,
     OPTION_SHADOW_PRIMARY,
+    OPTION_TEARFREE,
 } modesettingOpts;
 
 typedef struct
@@ -181,4 +182,5 @@ Bool ms_do_pageflip(ScreenPtr screen,
 
 #endif
 
+void ms_do_tearfree_flip(xf86CrtcPtr crtc);
 int ms_flush_drm_events(ScreenPtr screen);
diff --git a/hw/xfree86/drivers/modesetting/drmmode_display.c b/hw/xfree86/drivers/modesetting/drmmode_display.c
index 98ca3b2e2..c6a11d45b 100644
--- a/hw/xfree86/drivers/modesetting/drmmode_display.c
+++ b/hw/xfree86/drivers/modesetting/drmmode_display.c
@@ -1630,7 +1630,7 @@ drmmode_need_shadow_scanout(xf86CrtcPtr crtc) {
     if (crtc->rotation != RR_Rotate_0)
         return FALSE;
 
-    if (drmmode->shadow_primary)
+    if (drmmode->shadow_primary || drmmode->tear_free)
         return TRUE;
 
     /* check if the current screen size exceeds the driver's limits */
@@ -1671,6 +1671,7 @@ drmmode_set_mode_major(xf86CrtcPtr crtc, DisplayModePtr mode,
     drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
     drmmode_ptr drmmode = drmmode_crtc->drmmode;
     drmmode_shadow_scanout_ptr saved_shadow_nonrotated;
+    drmmode_shadow_scanout_ptr saved_shadow_nonrotated_back;
     int saved_x, saved_y;
     Rotation saved_rotation;
     DisplayModeRec saved_mode;
@@ -1683,6 +1684,7 @@ drmmode_set_mode_major(xf86CrtcPtr crtc, DisplayModePtr mode,
     saved_y = crtc->y;
     saved_rotation = crtc->rotation;
     saved_shadow_nonrotated = drmmode_crtc->shadow_nonrotated;
+    saved_shadow_nonrotated_back = drmmode_crtc->shadow_nonrotated_back;
 
     if (mode) {
         crtc->mode = *mode;
@@ -1697,16 +1699,27 @@ drmmode_set_mode_major(xf86CrtcPtr crtc, DisplayModePtr mode,
         crtc->funcs->gamma_set(crtc, crtc->gamma_red, crtc->gamma_green,
                                crtc->gamma_blue, crtc->gamma_size);
 
+        drmmode_crtc->shadow_nonrotated = NULL;
+        drmmode_crtc->shadow_nonrotated_back = NULL;
+
         if (drmmode_need_shadow_scanout(crtc)) {
             drmmode_crtc->shadow_nonrotated = drmmode_shadow_scanout_create(crtc);
             if (!drmmode_crtc->shadow_nonrotated) {
                 xf86DrvMsg(crtc->scrn->scrnIndex, X_ERROR,
-                           "drmmode_scanout_shadow_init failed!\n");
+                           "drmmode_scanout_shadow_init failed for the frontbuffer!\n");
+                ret = FALSE;
+                goto done;
+            }
+        }
+
+        if (drmmode->tear_free) {
+            drmmode_crtc->shadow_nonrotated_back = drmmode_shadow_scanout_create(crtc);
+            if (!drmmode_crtc->shadow_nonrotated_back) {
+                xf86DrvMsg(crtc->scrn->scrnIndex, X_ERROR,
+                           "drmmode_scanout_shadow_init failed for the backbuffer!\n");
                 ret = FALSE;
                 goto done;
             }
-        } else {
-            drmmode_crtc->shadow_nonrotated = NULL;
         }
 
         can_test = drmmode_crtc_can_test_mode(crtc);
@@ -1720,6 +1733,7 @@ drmmode_set_mode_major(xf86CrtcPtr crtc, DisplayModePtr mode,
 
         /* We cannot fail anymore, free the previous scanout buffer */
         drmmode_scanout_destroy(crtc, saved_shadow_nonrotated);
+        drmmode_scanout_destroy(crtc, saved_shadow_nonrotated_back);
 
         if (crtc->scrn->pScreen)
             xf86CrtcSetScreenSubpixelOrder(crtc->scrn->pScreen);
@@ -1762,7 +1776,9 @@ drmmode_set_mode_major(xf86CrtcPtr crtc, DisplayModePtr mode,
          * restoring the previous values
          */
         drmmode_scanout_destroy(crtc, drmmode_crtc->shadow_nonrotated);
+        drmmode_scanout_destroy(crtc, drmmode_crtc->shadow_nonrotated_back);
         drmmode_crtc->shadow_nonrotated = saved_shadow_nonrotated;
+        drmmode_crtc->shadow_nonrotated_back = saved_shadow_nonrotated_back;
     } else
         crtc->active = TRUE;
 
@@ -4146,12 +4162,14 @@ drmmode_free_bos(ScrnInfoPtr pScrn, drmmode_ptr drmmode)
         dumb_bo_destroy(drmmode->fd, drmmode_crtc->cursor_bo);
 
         drmmode_scanout_destroy(crtc, drmmode_crtc->shadow_nonrotated);
+        drmmode_scanout_destroy(crtc, drmmode_crtc->shadow_nonrotated_back);
 
         /* HACK: make sure the shadow buffers are NULL because, when reseting, X
          * does not re-allocate the crtc structures, which keeps stale pointers
          * and leads to some use-after-free.
          */
         drmmode_crtc->shadow_nonrotated = NULL;
+        drmmode_crtc->shadow_nonrotated_back = NULL;
     }
 }
 
diff --git a/hw/xfree86/drivers/modesetting/drmmode_display.h b/hw/xfree86/drivers/modesetting/drmmode_display.h
index c6a48a56d..47f6b9a50 100644
--- a/hw/xfree86/drivers/modesetting/drmmode_display.h
+++ b/hw/xfree86/drivers/modesetting/drmmode_display.h
@@ -107,6 +107,9 @@ typedef struct {
     /** force creating a per-crtc framebuffer **/
     Bool shadow_primary;
 
+    /** Is Option "TearFree" enabled? */
+    Bool tear_free;
+
     /** Is Option "PageFlip" enabled? */
     Bool pageflip;
     Bool force_24_32;
@@ -179,6 +182,7 @@ typedef struct {
 
     drmmode_shadow_scanout_rec shadow_rotated;
     drmmode_shadow_scanout_ptr shadow_nonrotated;
+    drmmode_shadow_scanout_ptr shadow_nonrotated_back;
 
     PixmapPtr prime_pixmap;
     PixmapPtr prime_pixmap_back;
diff --git a/hw/xfree86/drivers/modesetting/modesetting.man b/hw/xfree86/drivers/modesetting/modesetting.man
index abf450c7c..67a5d8259 100644
--- a/hw/xfree86/drivers/modesetting/modesetting.man
+++ b/hw/xfree86/drivers/modesetting/modesetting.man
@@ -94,6 +94,14 @@ In an effort to reduce the performance cost, the latency may be negatively
 affected. The default is
 .B off.
 .TP
+.BI "Option \*qTearFree\*q \*q" boolean \*q
+Enable tearing prevention using the hardware page flipping mechanism. This
+option currently doesn't have any effect for rotated CRTCs. It requires
+allocating two separate scanout buffers for each non-rotated CRTC.
+.br
+This feature may reduce performance, increase latency and introduce stuttering. The default is
+.B off.
+.TP
 .SH "SEE ALSO"
 @xservername@(@appmansuffix@), @xconfigfile@(@filemansuffix@), Xserver(@appmansuffix@),
 X(@miscmansuffix@)
diff --git a/hw/xfree86/drivers/modesetting/pageflip.c b/hw/xfree86/drivers/modesetting/pageflip.c
index 027289f4e..407f524ec 100644
--- a/hw/xfree86/drivers/modesetting/pageflip.c
+++ b/hw/xfree86/drivers/modesetting/pageflip.c
@@ -356,4 +356,65 @@ error_out:
 #endif /* GLAMOR_HAS_GBM */
 }
 
+static void
+ms_scanout_flip_abort(void *data)
+{
+    drmmode_crtc_private_ptr drmmode_crtc = data;
+
+    if (drmmode_crtc->shadow_nonrotated_back)
+        drmmode_crtc->shadow_nonrotated_back->update_seq = 0;
+}
+
+static void
+ms_scanout_flip_handler(uint64_t frame, uint64_t usec, void *data)
+{
+    drmmode_crtc_private_ptr drmmode_crtc = data;
+    drmmode_shadow_scanout_ptr tmp;
+
+    if (!drmmode_crtc->shadow_nonrotated || !drmmode_crtc->shadow_nonrotated_back)
+        return;
+
+    /* the flip has happened, exchange the front and back buffers */
+    tmp = drmmode_crtc->shadow_nonrotated;
+    drmmode_crtc->shadow_nonrotated = drmmode_crtc->shadow_nonrotated_back;
+    drmmode_crtc->shadow_nonrotated_back = tmp;
+
+    /* allow the next update to queue a new flip */
+    ms_scanout_flip_abort(data);
+}
+
+void
+ms_do_tearfree_flip(xf86CrtcPtr crtc)
+{
+    drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
+    ScreenPtr screen = xf86ScrnToScreen(crtc->scrn);
+    uint32_t seq;
+
+    /* exit if the current crtc is off or not using tear-free */
+    if (!ms_crtc_on(crtc) || !drmmode_crtc->shadow_nonrotated_back)
+        return;
+
+    /* exit if an update has already been scheduled */
+    if (drmmode_crtc->shadow_nonrotated_back->update_seq)
+        return;
+
+    /* copy the screen pixmap to our current backbuffer */
+    drmmode_update_scanout_buffer(crtc,
+                                  drmmode_crtc->shadow_nonrotated_back);
+
+    seq = ms_drm_queue_alloc(crtc, drmmode_crtc, ms_scanout_flip_handler,
+                             ms_scanout_flip_abort);
+    if (!seq) {
+        xf86DrvMsg(crtc->scrn->scrnIndex, X_WARNING,
+                   "ms_drm_queue_alloc failed (%s). This may result in stale "
+                   "content displayed on the screen\n", strerror(errno));
+        return;
+    }
+
+    /* schedule a flip, and update the update_seq on success */
+    if (do_queue_flip_on_crtc(screen, crtc,
+                              drmmode_crtc->shadow_nonrotated_back->fb_id,
+                              DRM_MODE_PAGE_FLIP_EVENT, seq))
+        drmmode_crtc->shadow_nonrotated_back->update_seq = seq;
+}
 #endif
-- 
2.18.1


From 69ace56be1616d3d3c51e747dcb4cbf3626f2a40 Mon Sep 17 00:00:00 2001
From: Martin Peres <martin.peres@linux.intel.com>
Date: Wed, 19 Sep 2018 16:22:08 +0300
Subject: [PATCH 11/11] modesetting: add a NoAtomic option to ease testing of
 the legacy codepaths

Signed-off-by: Martin Peres <martin.peres@linux.intel.com>
---
 hw/xfree86/drivers/modesetting/driver.c        | 14 ++++++++++++--
 hw/xfree86/drivers/modesetting/driver.h        |  1 +
 hw/xfree86/drivers/modesetting/modesetting.man |  5 +++++
 3 files changed, 18 insertions(+), 2 deletions(-)

diff --git a/hw/xfree86/drivers/modesetting/driver.c b/hw/xfree86/drivers/modesetting/driver.c
index 78909ac02..5a4df98f6 100644
--- a/hw/xfree86/drivers/modesetting/driver.c
+++ b/hw/xfree86/drivers/modesetting/driver.c
@@ -133,6 +133,7 @@ static const OptionInfoRec Options[] = {
     {OPTION_DOUBLE_SHADOW, "DoubleShadow", OPTV_BOOLEAN, {0}, FALSE},
     {OPTION_SHADOW_PRIMARY, "ShadowPrimary", OPTV_BOOLEAN, {0}, FALSE},
     {OPTION_TEARFREE, "TearFree", OPTV_BOOLEAN, {0}, FALSE},
+    {OPTION_NO_ATOMIC, "NoAtomic", OPTV_BOOLEAN, {0}, FALSE},
     {-1, NULL, OPTV_NONE, {0}, FALSE}
 };
 
@@ -1124,8 +1125,17 @@ PreInit(ScrnInfoPtr pScrn, int flags)
 #endif
     }
 
-    ret = drmSetClientCap(ms->fd, DRM_CLIENT_CAP_ATOMIC, 1);
-    ms->atomic_modeset = (ret == 0);
+    if (!xf86ReturnOptValBool(ms->drmmode.Options, OPTION_NO_ATOMIC, FALSE)) {
+        ret = drmSetClientCap(ms->fd, DRM_CLIENT_CAP_ATOMIC, 1);
+        ms->atomic_modeset = (ret == 0);
+        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Atomic Mode Setting support: %s\n",
+                                             ms->atomic_modeset ? "True" : "False");
+    } else {
+        ms->atomic_modeset = FALSE;
+        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "The use Atomic Mode Setting has "
+                                             "been disabled\n");
+    }
+
 
     ms->kms_has_modifiers = FALSE;
     ret = drmGetCap(ms->fd, DRM_CAP_ADDFB2_MODIFIERS, &value);
diff --git a/hw/xfree86/drivers/modesetting/driver.h b/hw/xfree86/drivers/modesetting/driver.h
index 237c54f6a..cc3ba2744 100644
--- a/hw/xfree86/drivers/modesetting/driver.h
+++ b/hw/xfree86/drivers/modesetting/driver.h
@@ -53,6 +53,7 @@ typedef enum {
     OPTION_DOUBLE_SHADOW,
     OPTION_SHADOW_PRIMARY,
     OPTION_TEARFREE,
+    OPTION_NO_ATOMIC,
 } modesettingOpts;
 
 typedef struct
diff --git a/hw/xfree86/drivers/modesetting/modesetting.man b/hw/xfree86/drivers/modesetting/modesetting.man
index 67a5d8259..53fd9bb73 100644
--- a/hw/xfree86/drivers/modesetting/modesetting.man
+++ b/hw/xfree86/drivers/modesetting/modesetting.man
@@ -102,6 +102,11 @@ allocating two separate scanout buffers for each non-rotated CRTC.
 This feature may reduce performance, increase latency and introduce stuttering. The default is
 .B off.
 .TP
+.BI "Option \*qNoAtomic\*q \*q" boolean \*q
+Disable atomic mode setting usage. Useful during developement for validating
+legacy codepaths. The default is
+.B off.
+.TP
 .SH "SEE ALSO"
 @xservername@(@appmansuffix@), @xconfigfile@(@filemansuffix@), Xserver(@appmansuffix@),
 X(@miscmansuffix@)
-- 
2.18.1

